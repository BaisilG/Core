<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Stringier.Patterns </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Stringier.Patterns ">
    <meta name="generator" content="docfx 2.45.0.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="stringierpatterns">Stringier.Patterns</h1>

<p>Patterns, probably introduced with SNOBOL, and also seen with SPITBOL and UNICON, are considerably more powerful than Regular Expressions. So what do you do when you need to parse something more complicated than a Regex? Hacky Regex extensions aren't great, and still lack what some advanced alternatives can offer. Parser Concatenators? Actually these are great. I'm not going to bash them at all. Pattern Matching and Parser Concatenators share a huge amount of theory and implementation details. You could consider them alternative interpretations of the same concept. That being said, you'll notice a few small differences, but the advantages apply to both.</p>
<h2 id="including">Including</h2>
<pre><code class="lang-csharp">using System.Text.Patterns;
</code></pre>
<h2 id="usage">Usage</h2>
<p>In most situations, there's only three usage patterns you'll need to know.</p>
<h3 id="declaration">Declaration</h3>
<pre><code class="lang-csharp">Pattern patternName = &quot;Text to match&quot;;
// Comparison of a Literal
</code></pre>
<p>or</p>
<pre><code class="lang-csharp">Pattern patternName = (&quot;Text to match&quot;, StringComparison.CurrentCultureIgnoreCase);
// Comparisons of this Literal will use the StringComparison value
</code></pre>
<p>or</p>
<pre><code class="lang-csharp">Pattern patternName = literalPattern1 &amp; (literalPattern2 | literalPattern3);
// Comparison of an actual pattern
</code></pre>
<h3 id="matching">Matching</h3>
<pre><code class="lang-csharp">patternName.Consume(&quot;Candidate text&quot;);
//Assuming Consume captures &quot;Candidate&quot; this will return true and &quot;Candidate&quot;
</code></pre>
<h3 id="inline-quick-match">Inline (Quick Match)</h3>
<pre><code class="lang-csharp">&quot;Hello&quot;.Consume(&quot;Hello World!&quot;);
//Assuming &quot;Hello&quot; captures &quot;Hello&quot; (which it obviously will) this will return true and &quot;Hello&quot;
</code></pre>
<p>or</p>
<pre><code class="lang-csharp">' '.Consume(&quot; okay &quot;);
//Assuming ' ' captures the first character in &quot; okay &quot; (which it obviously will) this will return true and &quot; &quot;.
</code></pre>
<h2 id="concepts">Concepts</h2>
<h3 id="multiple-return-values">Multiple return values</h3>
<p>Pattern matching is largely based around the idea of goal-direction. The two most likely languages you're using this library from <strong>C#</strong> and <strong>VB.NET</strong> don't support goal-direction (if you're using <strong>F#</strong> then <a href="http://www.quanttec.com/fparsec/">FParsec</a> is going to match that programming style better anyways). Goal-directed semantics require both a success state and the result to be returned from every function call (or just the success state for a <code>void</code> return).</p>
<blockquote>
<p>But wait, C# can't return multiple values!</p>
</blockquote>
<p>While true, this is remarkably pedantic. Whether you return an array, a struct, a class, or a tuple, you are returning multiple values as one conceptual value. All the parsing methods return <code>Result</code> which contains both the success state (<code>Boolean</code>) and the result of the operation (<code>String</code>). <code>Result</code> implicitly casts to both <code>Boolean</code> and <code>String</code> and can be used as such. This allows some conveniences without adding new methods.</p>
<blockquote>
<p>So every return passes two values? Isn't that a lot of extra memory?</p>
</blockquote>
<p>One, no not really, a single <code>Boolean</code> isn't very large. Two, it doesn't actually pass a <code>Boolean</code> at all. An empty string is recognized as a failure. Essentially <code>Result</code> is a box of <code>String</code> with special comparisons and implicit conversions. In other words, the behavior of <code>Parse</code> and <code>TryParse</code> combined into one method. And, getting technical, we're not actually passing around <code>String</code> either. We're actually passing around <a href="https://docs.microsoft.com/en-us/dotnet/api/system.span-1"><code>Span&lt;Char&gt;</code></a> for performance reasons; actually passing around references to parts of the string, preventing copying in most situations.</p>
<h3 id="literal">Literal</h3>
<pre><code class="lang-csharp">Pattern patternName = &quot;Literal Pattern&quot;;
</code></pre>
<p>or</p>
<pre><code class="lang-csharp">Pattern patternName = 'p';
</code></pre>
<p>This is an exact 1:1 match pattern, and is equivalent to</p>
<pre><code class="lang-csharp">&quot;pattern&quot; == &quot;candidate&quot;
</code></pre>
<p><strong>Literal</strong> is meant mostly as a building block for patterns. Because pattern operators expect to use a <strong>Literal</strong>, which is not a string, the convenient syntax shown above only applies to <strong>Literal</strong>. Use inside a pattern operator might require a cast like</p>
<pre><code class="lang-csharp">(Pattern)&quot;Literal Pattern&quot; &amp; &quot;Other Literal Pattern&quot;
</code></pre>
<p>This is generally only required as the very first member</p>
<p>Consider using characters anywhere a single character should be matched. While a string containing a single element will perform the same match, character matching is quicker.</p>
<h3 id="alternator">Alternator</h3>
<pre><code class="lang-csharp">Pattern patternName = pattern1 | pattern2;
</code></pre>
<p>Alternators accept either pattern, and are equivalent to the regex <code>(pattern1|pattern2)</code>.</p>
<h3 id="concatenator">Concatenator</h3>
<pre><code class="lang-csharp">Pattern patternName = pattern1 &amp; pattern2;
</code></pre>
<p>Concatenators require both patterns in sequence and are equivalent to the regex <code>(pattern1)(pattern2)</code> with the unnecessary parenthesis added for readability.</p>
<h3 id="negator">Negator</h3>
<pre><code class="lang-csharp">Pattern patternName = !pattern;
</code></pre>
<p>Negators exclude the specified pattern, instead consuming anything of the same length. This is not a concept easy to express with regex, but given the pattern <code>!&quot;hi&quot;</code> it would be similar to <code>/[^h][^i]/</code>.</p>
<h3 id="optor">Optor</h3>
<pre><code class="lang-csharp">Pattern patternName = ~pattern;
</code></pre>
<p>Optors make the pattern completly optional, so success is always true, and are equivalent to the regex <code>(pattern)?</code>.</p>
<h3 id="range-patterns">Range Patterns</h3>
<pre><code class="lang-csharp">RangePattern patternName = new RangePattern(From: startPattern, To: endPattern);
</code></pre>
<p>or</p>
<pre><code class="lang-csharp">rangePattern patternName = new RangePattern(From: startPattern, To: endPattern, Escape: escapePattern);
</code></pre>
<p>Ranger Patterns are totally foreign to Regex, although some parsers are able to synthesize the behavior. The behavior is to simply try matching the <code>From</code> at the current position, then continue to read everything until the <code>To</code> is matched, which also consumes that. Optionally, an <code>Escape</code> may be defined, which is attempted to be matched before <code>To</code> and is used primarily for matching string literals which have language defined escape sequences for the delimiting character.</p>
<p>To provide a few examples of how this behavior is useful:</p>
<pre><code class="lang-csharp">RangePattern letStatement = new RangePattern(From: &quot;let&quot;, To: &quot;;&quot;); //This will match an entire let statement in a language which has semicolon terminated statements
</code></pre>
<pre><code class="lang-csharp">RangePattern cString = new RangePattern(From: &quot;\&quot;&quot;, To: &quot;\&quot;&quot;, Escape: &quot;\\\&quot;&quot;); //This will match an entire C string literal, while including double-quote escapes
</code></pre>
<p>It is important to understand that this is not a modified pattern, but rather a new <code>struct</code>. That is because some of the modifiers, especially <code>Negator</code>, do not conceptually apply to a range (what is a negated range capture?).</p>
<h3 id="repeater">Repeater</h3>
<pre><code class="lang-csharp">Pattern patternName = pattern * 3; //repeats the pattern three times
</code></pre>
<p>Repeaters require the pattern to repeat the specified number of times, and can be thought of the multiplcation to patterns when Concatenators are addition. The above example would be equivalent to the regex <code>(pattern){3}</code>.</p>
<h3 id="spanner">Spanner</h3>
<pre><code class="lang-csharp">Pattern patternName = +pattern;
</code></pre>
<p>Spanners require the pattern to exist at least once, but will repeat until the pattern can no longer be matched, and are equivalent to the regex <code>(pattern)+</code>.</p>
<h3 id="checker">Checker</h3>
<pre><code class="lang-csharp">Pattern patternName = (Pattern)((Char) =&gt;
    //Logic
);
</code></pre>
<p>Checkers aren't normally used, but seeing as they form the basis of a lot of predefined patterns because of their usability, they are also exposed publicly to enable certain complex patterns or greatly simplify complex patterns. Instead of doing checks through the pattern API, the check, held only against a single character, is done programmatically. The check is a lamba which takes a single character and returns a boolean. Anything can be done in this context. Overwhelmingly you don't want to use this.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/Entomy/Stringier/blob/master/Stringier.Patterns/README.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
